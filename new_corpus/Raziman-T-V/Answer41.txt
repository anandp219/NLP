For this  along with [math]\rm{DP}(i S)[/math]  we keep another variable [math]b(i S)[/math] which stores the value of [math]b_i[/math] which gives the minimum for [math]\rm{DP}(i S)[/math]. We will do the DP by memoised recursion to avoid calculating some unnecessary values. 1 2 3 4 5 6 7 8 9101112131415161718192021222324252627282930313233int DP[101][1<<16] b[101][1<<16];memset(DP -1 sizeof DP);int calc(int i int mask){ //Base case if(i==0)return 0; //Check for memoisation if(DP[i][mask]!=-1) return DP[i][mask]; //Start by assigning 1 to current element //1 has no prime factors  so mask passed is unchanged DP[i][mask]=calc(i-1 mask) + abs(a[i]-1); b[i][mask]=1; //Now consider all values j from 2 to 58 for(int j=2;j<59;j++) { //Ensure that all factors of j exist in mask : This is true iff (mask&factormask[j]) == factormask[j] if((mask&factormask[j])!=factormask[j]) continue;  //Factors of j can be removed from mask using (mask^factormask[j]) int cur=calc(i-1 mask^factormask[j]) + abs(a[i]-j); if(cur<DP[i][mask]) { //We found a better j DP[i][mask]=cur; b[i][mask]=j; } } return DP[i][mask];}We can now call calc(i (1<<16)-1) and then build the [math]b_i[/math]s in the end.