 This is a tricky dynamic programming question.Let us start with a naive DP solution of high complexity.Definewin(i,j,k)=1 iff player i could have emerged as the survivor after battles involving only players in the clockwise range from j to k (that is, if j>k, the range wraps around n)Clearly, i has to fall inside [j,k] for win(i,j,k) to make sense. Also, the clockwise range is taken as linear even if it spans the full circle. For example, if n=5 and j=3,k=2, the range looks like [3,4,5,1,2]; and 3 cannot fight 2 until everyone in between has been defeated.We need to find a recurrence for win(i,j,k). The last duel has to be won by i. The opponent of this duel has to be some muskeeter i'. Without loss of generality, suppose the i' is situated clockwise to i. Consider all the musketeers who lost to i' or lost to someone who lost to i' and so on. It is easy to see that all these musketeers have to be situated in a contiguous segment [k',k] for some value of k. Similarly, before i defeated i', all the musketeers who lost to i or lost to someone who lost to i and so on, form another contiguous segment [j,k'-1].Thus we obtain the recurrence:win(i,j,k) = 1IFFthere exist i', j' : ji'j'<i and win(i',j,j')=1 and win(i,j'+1,k) = 1 and i defeats i'ORthere exist i', k' : i<k'i'k and win(i',k',k)=1 and win(i,j,k'-1) = 1 and i defeats i'We are essentially looping over all possible last opponents and the segments they have conquered individually. The complexity of this recurrence to fill the win(i,j,k) table is O(N).Can we do better?Yes. the important thing to note is that the players to the left and right of i are independent. Since they do not "talk" to each other, everything to the right can be finished off before the left, or vice versa. This suggests that we can split our win function into two:rightwin(i,k) = 1 iff i could have emerged as the survivor after battles involving only players in the clockwise range from i to kleftwin (i,j) = 1 iff i could have emerged as the survivor after battles involving only players in the anticlockwise range from i to jIt is easy to see that win(i,j,k) = leftwin(i,j) AND rightwin(i,k).The recurrence for rightwin(i,k) is essentially the same as beforerightwin(i,k) = 1IFFthere exist i', k' : i<k'i'k and rightwin(i,k'-1)=1 and leftwin(i',k')=1 and rightwin(i',k)=1 and i defeats i' The leftwin recurrence is symmetric. The tables rightwin(i,k) and leftwin(i,j) can be filled in O(N) and thus, win(i,j,k) can be computed for all values in O(N).It seems we can still do betterFor this, we have to finally use the fact that the range wraps around. Suppose we want i to win. Imagine all the players standing in the circle and duelling each other till only two are left : i and some i'. All the musketeers between i and i' (clockwise) have to be defeated by one of them (or someone who defeated them...). Similarly, all musketeers between i' and i (clockwise) have to be defeated too.Thus we modify the definition of our rightwin function slightly:rightwin(i,k) = 1 iff i and k can defeat everyone in the range (i,k) togetheri can survive the full set of duels if there exists some i' such that rightwin(i,i') = rightwin(i',i) = 1 and i can defeat i'. It is easy to see that, with cooperation, our recurrence simplifies further:rightwin(i,k) = 1IFFthere exists k':i<k'<k such that rightwin(i,k') = rightwin(k',k) = 1ANDi or k can defeat k'We can evaluate the rightwin(i,k) table thus in O(N) time. Since N100, this should be quick enough.