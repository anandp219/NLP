Continue popping elements till you find a line where the intersection point [math]p[/math] lies in its candidate range. Update the right limit of the candidate range of the line as [math]p[/math]  and push the current line to the stack with candidate range [math][p \infty)[/math].Once this preprocessing is done  finding the lowest line at a given x-coordinate is simple. We can binary search over the ranges of the candidate lines and see which one [math]x[/math] falls in. Alternately  we can sort the x-coordinates of the consumers first and scan the ranges from left to right.Pseudocode: 1 2 3 4 5 6 7 8 91011121314151617181920212223242526272829Given : (a[i] b[i]) for i=1 to M : x[j] for j=1 to Nfor i = 1 to M line[i].index = i line[i].slope = -2 a[i] line[i].intercept = a[i]^2 + b[i]^2endsort line[] in decreasing order of slope  breaking ties in increasing order of interceptstack sline[1].range=(-inf inf)push line[1] to stackfor i = 2:M if slope[i] == slope[i-1] continue while (c = x-coordinate of intersection of line[i] and s.top) <= s.top.range.left pop from s s.top.range.right=c line[i].range=(c inf) push line[i] to stackendfor j = 1 to N binary search on s to find line[i] such that x[j] lies in line[i].range output line[i].indexendComplexity of the solution is [math]O((N+M) \log M)[/math].