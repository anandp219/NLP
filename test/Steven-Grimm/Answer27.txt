No amount of inner-loop optimization will beat switching to a lower order of complexity for a sufficiently large input. Your profiling data is still useful here  though  in that it'll tell you which of the O(n) algorithms in your code are actually causing problems; algorithms that run in polynomial time are perfectly fine if the inputs are guaranteed to be small.Only after you've ensured that you need to do the work at all  that you've identified the source of the performance problem  and that you're not choosing algorithms that are slow by nature  should you dive into language-specific micro-optimizations.